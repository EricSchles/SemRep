/*
 * VulnerabilitySignatureGenerator.cpp
 *
 * Copyright (C) 2013-2014 University of California Santa Barbara.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the  Free Software
 * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335,
 * USA.
 *
 * Authors: Abdulbaki Aydin, Muath Alkhalaf
 */

#include "VulnerabilitySignatureGenerator.hpp"

PerfInfo VSGenerator::perfInfo;

VSGenerator::VSGenerator(string input_dep_graph_file_name, string input_field_name,	string attack_pattern) {
	this->dep_graph_file_name = input_dep_graph_file_name;
	this->input_field_name = input_field_name;

	this->dep_graph = DepGraph::parseDotFile(input_dep_graph_file_name);
	this->uninit_field_node = dep_graph.findInputNode(input_field_name);

	if (uninit_field_node == nullptr) {
		throw StrangerStringAnalysisException("Cannot find input node " + input_field_name + " in dep graph.");
	}
	message(stringbuilder() << "uninit node(" << uninit_field_node->getID() << ") found for field " << input_field_name << ".");

	this->field_relevant_dep_graph = dep_graph.getInputRelevantGraph(uninit_field_node);

	ImageComputer::perfInfo = &VSGenerator::perfInfo;
	ImageComputer::staticInit();

	this->attack_pattern_auto = StrangerAutomaton::regExToAuto(attack_pattern);
	this->sink_auto = nullptr;
	this->vs_auto = nullptr;

	enable_debug = false;
}
VSGenerator::~VSGenerator() {
	delete this->attack_pattern_auto;
	delete this->sink_auto;
	delete this->vs_auto;
}

AnalysisResult VSGenerator::analyzePostImages() {
	AnalysisResult analysis_result;

	UninitNodesList uninit_nodes = dep_graph.getUninitNodes();
	message(stringbuilder() << "initializing inputs with bottom other than: " << input_field_name );
	for (auto uninit_node : uninit_nodes) {
		analysis_result[uninit_node->getID()] = StrangerAutomaton::makePhi(uninit_node->getID());
	}

	message(stringbuilder() << "initializing input node: "<< input_field_name << "(" << uninit_field_node->getID() << ") with sigma star");
	delete analysis_result[uninit_field_node->getID()];
	analysis_result[uninit_field_node->getID()] = StrangerAutomaton::makeAnyString(uninit_field_node->getID());

	ImageComputer analyzer;

	try {

		message("starting forward analysis...");
		analyzer.doForwardAnalysis_SingleInput(dep_graph, field_relevant_dep_graph, analysis_result);
		message("...finished forward analysis.");

	} catch (StrangerStringAnalysisException const &e) {
        cerr << e.what();
        exit(EXIT_FAILURE);
    }

	return analysis_result;
}

AnalysisResult VSGenerator::analyzePreImages(StrangerAutomaton* intersection_auto, const AnalysisResult& fwAnalysisResult) {
	ImageComputer analyzer;
	AnalysisResult analysis_result;

	try {
		message("starting backward analysis...");
		analyzer.doBackwardAnalysis_GeneralCase(dep_graph, field_relevant_dep_graph, intersection_auto, fwAnalysisResult);
		message("...finished backward analysis.");

	} catch (StrangerStringAnalysisException const &e) {
        cerr << e.what();
        exit(EXIT_FAILURE);
    }

	return analysis_result;
}

StrangerAutomaton* VSGenerator::generateVS() {

	AnalysisResult fwAnalysisResult = analyzePostImages();

	sink_auto = fwAnalysisResult[dep_graph.getRoot()->getID()];
	if (enable_debug) {
		message("Post image of sink node:");
		debug_auto(sink_auto, 0);
	}

	StrangerAutomaton* intersection = sink_auto->intersect(attack_pattern_auto,dep_graph.getRoot()->getID());

	if (intersection->isEmpty()) {
		message("Attack pattern can not be exploited, no vulnerability signature");
		return nullptr;
	}

	AnalysisResult bwAnalysisResult = analyzePreImages(intersection, fwAnalysisResult);
	vs_auto = bwAnalysisResult[uninit_field_node->getID()];
	if (enable_debug) {
		message("Vulnerability Signature:");
		debug_auto(vs_auto, 0);
	}
	return vs_auto;
}

void VSGenerator::writeVStoFile(string file_name) {
	if(vs_auto != nullptr) {
		vs_auto->toDotFile(file_name);
	}
}

void VSGenerator::debug_auto(StrangerAutomaton* automaton, int type) {
	switch (type) {
		case 0:
			automaton->toDotAscii(0);
			break;
		case 1:
			automaton->toDotAscii(1);
			break;
		case 2:
			automaton->toDot();
			break;
		default:
			automaton->toDotAscii(0);
			break;
	}
}

void VSGenerator::message(string msg) {
	cout << endl << "~~~~~~~~~~~>>> VS Generator says: " << msg << endl;
}


